Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    LINE_COMMENT
    POINT
    EQ
    NEQ
    GT
    LT
    GET
    LET
    ASSIGN
    COL
    SEMCOL
    IF
    ELSE
    WHILE
    CLASS
    AND
    OR
    NOT

Grammar

Rule 0     S' -> sumExpr
Rule 1     sumExpr -> sumExpr sumop term
Rule 2     sumExpr -> term
Rule 3     sumop -> SUM
Rule 4     sumop -> SUBST
Rule 5     term -> term mulop opElement
Rule 6     term -> opElement
Rule 7     opElement -> name
Rule 8     opElement -> number
Rule 9     mulop -> PROD
Rule 10    mulop -> DIV
Rule 11    inputStmt -> INPUT LPARENT RPARENT
Rule 12    outputStmt -> PRINT LPARENT STRING RPARENT
Rule 13    number -> NUMBER
Rule 14    string -> STRING
Rule 15    name -> NAME

Terminals, with rules where they appear

AND                  : 
ASSIGN               : 
CLASS                : 
COL                  : 
DIV                  : 10
ELSE                 : 
EQ                   : 
GET                  : 
GT                   : 
IF                   : 
INPUT                : 11
LET                  : 
LINE_COMMENT         : 
LPARENT              : 11 12
LT                   : 
NAME                 : 15
NEQ                  : 
NOT                  : 
NUMBER               : 13
OR                   : 
POINT                : 
PRINT                : 12
PROD                 : 9
RPARENT              : 11 12
SEMCOL               : 
STRING               : 12 14
SUBST                : 4
SUM                  : 3
WHILE                : 
error                : 

Nonterminals, with rules where they appear

inputStmt            : 
mulop                : 5
name                 : 7
number               : 8
opElement            : 5 6
outputStmt           : 
string               : 
sumExpr              : 1 0
sumop                : 1
term                 : 1 2 5

Parsing method: LALR

state 0

    (0) S' -> . sumExpr
    (1) sumExpr -> . sumExpr sumop term
    (2) sumExpr -> . term
    (5) term -> . term mulop opElement
    (6) term -> . opElement
    (7) opElement -> . name
    (8) opElement -> . number
    (15) name -> . NAME
    (13) number -> . NUMBER

    NAME            shift and go to state 6
    NUMBER          shift and go to state 7

    sumExpr                        shift and go to state 1
    term                           shift and go to state 2
    opElement                      shift and go to state 3
    name                           shift and go to state 4
    number                         shift and go to state 5

state 1

    (0) S' -> sumExpr .
    (1) sumExpr -> sumExpr . sumop term
    (3) sumop -> . SUM
    (4) sumop -> . SUBST

    SUM             shift and go to state 9
    SUBST           shift and go to state 10

    sumop                          shift and go to state 8

state 2

    (2) sumExpr -> term .
    (5) term -> term . mulop opElement
    (9) mulop -> . PROD
    (10) mulop -> . DIV

    SUM             reduce using rule 2 (sumExpr -> term .)
    SUBST           reduce using rule 2 (sumExpr -> term .)
    $end            reduce using rule 2 (sumExpr -> term .)
    PROD            shift and go to state 12
    DIV             shift and go to state 13

    mulop                          shift and go to state 11

state 3

    (6) term -> opElement .

    PROD            reduce using rule 6 (term -> opElement .)
    DIV             reduce using rule 6 (term -> opElement .)
    SUM             reduce using rule 6 (term -> opElement .)
    SUBST           reduce using rule 6 (term -> opElement .)
    $end            reduce using rule 6 (term -> opElement .)


state 4

    (7) opElement -> name .

    PROD            reduce using rule 7 (opElement -> name .)
    DIV             reduce using rule 7 (opElement -> name .)
    SUM             reduce using rule 7 (opElement -> name .)
    SUBST           reduce using rule 7 (opElement -> name .)
    $end            reduce using rule 7 (opElement -> name .)


state 5

    (8) opElement -> number .

    PROD            reduce using rule 8 (opElement -> number .)
    DIV             reduce using rule 8 (opElement -> number .)
    SUM             reduce using rule 8 (opElement -> number .)
    SUBST           reduce using rule 8 (opElement -> number .)
    $end            reduce using rule 8 (opElement -> number .)


state 6

    (15) name -> NAME .

    PROD            reduce using rule 15 (name -> NAME .)
    DIV             reduce using rule 15 (name -> NAME .)
    SUM             reduce using rule 15 (name -> NAME .)
    SUBST           reduce using rule 15 (name -> NAME .)
    $end            reduce using rule 15 (name -> NAME .)


state 7

    (13) number -> NUMBER .

    PROD            reduce using rule 13 (number -> NUMBER .)
    DIV             reduce using rule 13 (number -> NUMBER .)
    SUM             reduce using rule 13 (number -> NUMBER .)
    SUBST           reduce using rule 13 (number -> NUMBER .)
    $end            reduce using rule 13 (number -> NUMBER .)


state 8

    (1) sumExpr -> sumExpr sumop . term
    (5) term -> . term mulop opElement
    (6) term -> . opElement
    (7) opElement -> . name
    (8) opElement -> . number
    (15) name -> . NAME
    (13) number -> . NUMBER

    NAME            shift and go to state 6
    NUMBER          shift and go to state 7

    term                           shift and go to state 14
    opElement                      shift and go to state 3
    name                           shift and go to state 4
    number                         shift and go to state 5

state 9

    (3) sumop -> SUM .

    NAME            reduce using rule 3 (sumop -> SUM .)
    NUMBER          reduce using rule 3 (sumop -> SUM .)


state 10

    (4) sumop -> SUBST .

    NAME            reduce using rule 4 (sumop -> SUBST .)
    NUMBER          reduce using rule 4 (sumop -> SUBST .)


state 11

    (5) term -> term mulop . opElement
    (7) opElement -> . name
    (8) opElement -> . number
    (15) name -> . NAME
    (13) number -> . NUMBER

    NAME            shift and go to state 6
    NUMBER          shift and go to state 7

    opElement                      shift and go to state 15
    name                           shift and go to state 4
    number                         shift and go to state 5

state 12

    (9) mulop -> PROD .

    NAME            reduce using rule 9 (mulop -> PROD .)
    NUMBER          reduce using rule 9 (mulop -> PROD .)


state 13

    (10) mulop -> DIV .

    NAME            reduce using rule 10 (mulop -> DIV .)
    NUMBER          reduce using rule 10 (mulop -> DIV .)


state 14

    (1) sumExpr -> sumExpr sumop term .
    (5) term -> term . mulop opElement
    (9) mulop -> . PROD
    (10) mulop -> . DIV

    SUM             reduce using rule 1 (sumExpr -> sumExpr sumop term .)
    SUBST           reduce using rule 1 (sumExpr -> sumExpr sumop term .)
    $end            reduce using rule 1 (sumExpr -> sumExpr sumop term .)
    PROD            shift and go to state 12
    DIV             shift and go to state 13

    mulop                          shift and go to state 11

state 15

    (5) term -> term mulop opElement .

    PROD            reduce using rule 5 (term -> term mulop opElement .)
    DIV             reduce using rule 5 (term -> term mulop opElement .)
    SUM             reduce using rule 5 (term -> term mulop opElement .)
    SUBST           reduce using rule 5 (term -> term mulop opElement .)
    $end            reduce using rule 5 (term -> term mulop opElement .)

